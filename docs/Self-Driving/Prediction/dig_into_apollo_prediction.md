# Dig into Apollo(6.0) Prediction

![prediction](images/apollo_prediction/class_diagram.png)

## PredictionComponent

### Proc

This is a callback function for `PerceptionObstacle` Reader. If a new message is generated in channel, this function will execute.

```C++
if (FLAGS_use_lego) return ContainerSubmoduleProcess(perception_obstacles);
return PredictionEndToEndProc(perception_obstacles); 
```

### ContainerSubmoduleProcess

This is another prediction process which is the same as `PredictionEndToEnd`. This function is created for `Lego` architecture, whose communication system may have much difference with current `cyber`.

### PredictionEndToEnd

Almost all the work is doing in `MessageProcess` class.

- Transform all messages(perception/localization/planning/storytelling) to obstacle
- `message_process.OnPerception`
- Send the prediction message to channel

## MessageProcess

### Init

Initialize following classes with configures:

- ContainerManager
- EvaluatorManager
- PredictorManager
- PredictionMap

### OnPerception

Prediction module is driven by perception module, which means that once a frame of message is generated by perception, this function is called. The process is:

- use `ContainerProcess` function to process all messages
- insert all messages to a proto file for offline model training
- generate intension of obstacle with `evaluator` module
- generate trajectory of obstacle with `predictor` module

### ContainerProcess

This function :

- transforms messages from perception/localization/planning to abstract obstacles and
- prioritizes all obstacles to determine if the obstacle is need to consider and
- analyzes scenarios ego vehicle is in of:
    - Unknown
    - Cruise
    - Junction
- builds junction(conditional) and cruise features and
- sets `Caution` priority of obstacle and
- sets the weight of way in a distance to
    - -20, for left turn
    - -10, for right turn

## ObstaclePrioritizer

### AssignIgnoreLevel

This function set obstacle's priority of:

- `Ignore`, which means it's no need to consider
- `Normal`, which means it should be considered

And if an obstacle's priority is `Normal`, it is either:

- in `scan box`, which is a rectangular centered on ego vehicle
- on lane
- near lane with the type of `pedestrian`
- near junction

### AssignCautionLevel

Set the obstacle priority to be `Caution` if the obstacle is close to ego vehicle and

- in junction(under junction scenario)
- the first obstacle in front of ego vehicle(searched within lane sequence, may not be unique)
- its lane sequence is on ego vehicle's planning trajectory

And if enabled, this function will shrink the number of caution obstacles to a threshold according to distance.


## EvaluatorManager

`EvaluatorManager` class to manage all `Evaluator`s' lifecycle and 

### Init

This is a initialization function to initialize:

- semantic map
- all evaluators with configures
- default evaluator types by obstacle's:
    - type
    - priority(normal/caution)
    - status(onlane/offlane/junction)

### GetEvaluator

You can get the pointer to evaluator by inputing evaluator's type. It's better to use unordered_map(hash) other than map(balanced binary tree) to accumulate the looking up process.

### Run

This is the main process to `evaluate` an obstacle's intension(or trajectory) with multiple evaluators.
According to `Single Responsibility` principle, I don't think it's a good idea to do these stuffs in a `manager` class.

The function does:

- BuildObstacleIdHistoryMap
- DumpCurrentFrameEnv
- Evaluate obstacles with:
    - multiple thread according to `GroupObstaclesByObstacleIds` results
    - single thread

### BuildObstacleIdHistoryMap

Build a feature proto for each obstacle in current frame, every feature proto contains `max_num_frame`s with:

- id
- timestamp
- type
- position(x, y, z)
- theta(heading)
- length
- width
- is_trainable(bool, calculated with the function `IsTrainable`)

### IsTrainable

A helper function defined in `evaluator_manager.cc`'s unnamed namespace. Return `false` if the obstacle:

- is ego vehicle
- has the priority of `Ignore`
- is still
- is not vehicle

otherwise, return true;

### DumpCurrentFrameEnv

Another helper fucntion in unnamed namespace, the main purpose of this is to insert all obstacles' history information to `FrameEnv` class for output.

### GroupObstaclesByObstacleIds

This function assigns thread id for each obstacle according to its priority(caution or normal). Each thread has `obstacle_num / thread_num` obstacle ids(tasks).

#### CyclistKeepLaneEvaluator
The `CyclistKeepLaneEvaluator` is simple and has only two probability values:

- 1.0, if current lane id is equal to the lane id in lane sequence;
- 0.0, if current lane id is not equal to the lane id in lane sequence.

The lanes sequence is a list of lane id that covers the length:

$$
D_{lane} = v_{0} * t_{max} + 0.5 * a_{max} * t_{max}^2
$$

In equation,

- $D_{lane}$ is the distance the lane sequance covers;
- $v_{0}$ is current speed the obstacle has;
- $t_{max}$ is the predicted trajectory duration, it's 8.0 in program;
- $a_{max}$ is the maximum linear acceleration of vehicle, it's 4.0 in program;

### PedestrianInteractionEvaluator

This evaluator follows the paper[Social LSTM: Human Trajectory Prediction in Crowded Spaces](https://cvgl.stanford.edu/papers/CVPR16_Social_LSTM.pdf). I guess that this evaluator is not completed, because:

- the input trajectory size is only one
- the social part of work is not implemented, and without the social, lstm has little advance over constant velocity model.

### CostEvaluator
`CostEvaluator` calculates the probability based on the distance between obstacle and lane boundary.

$$
E_{l} = \frac{W_{lane}}{2} - W_{l}
$$

$$
P_{cost} = \frac{1}{1 + e^{-E_{l}}}
$$

In the equation:

- $E_{l}$ is the distance from lane boundary to obstacle's location;
- $W_{lane}$ is the width of lane;
- $W_{l}$ is the lateral distance from lane reference line to obstacle's location;
- $P_{cost}$ is the probability, calculated by a [Sigmoid function](https://en.wikipedia.org/wiki/Sigmoid_function).
